import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import subprocess
import threading
import os

class CodeEditor:
    def __init__(self, root):
        self.root = root
        self.root.title("Code Editor with Local LLM")
        self.root.geometry("1000x700")
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Create Code Editor Tab
        self.create_code_editor_tab()
        
        # Create LLM Tab
        self.create_llm_tab()
        
    def create_code_editor_tab(self):
        code_frame = ttk.Frame(self.notebook)
        self.notebook.add(code_frame, text="Code Editor")
        
        # Text editor with line numbers
        editor_paned = tk.PanedWindow(code_frame, orient=tk.HORIZONTAL)
        editor_paned.pack(fill=tk.BOTH, expand=True)
        
        # Line numbers
        self.line_numbers = tk.Text(editor_paned, width=4, padx=3, takefocus=0,
                                   border=0, state='disabled', wrap='none',
                                   background='#f0f0f0', font=('Consolas', 12))
        editor_paned.add(self.line_numbers)
        
        # Code text area
        self.code_text = tk.Text(editor_paned, wrap=tk.NONE, font=('Consolas', 12),
                                undo=True, maxundo=50)
        editor_paned.add(self.code_text)
        
        # Scrollbars
        y_scrollbar = tk.Scrollbar(self.code_text, orient='vertical', command=self.on_textscroll)
        y_scrollbar.pack(side=tk.RIGHT, fill='y')
        self.code_text.config(yscrollcommand=y_scrollbar.set)
        
        x_scrollbar = tk.Scrollbar(code_frame, orient='horizontal', command=self.code_text.xview)
        x_scrollbar.pack(side=tk.BOTTOM, fill='x')
        self.code_text.config(xscrollcommand=x_scrollbar.set)
        
        # Button frame
        button_frame = ttk.Frame(code_frame)
        button_frame.pack(fill=tk.X, pady=5)
        
        # Buttons
        ttk.Button(button_frame, text="Save (.py)", command=self.save_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Run Code", command=self.run_code).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Copy Code", command=self.copy_code).pack(side=tk.LEFT, padx=5)
        
        # Output area
        ttk.Label(code_frame, text="Output:").pack(anchor=tk.W)
        self.output_text = tk.Text(code_frame, height=8, font=('Consolas', 10),
                                  bg='#f5f5f5', state='disabled')
        self.output_text.pack(fill=tk.BOTH, expand=False, padx=5, pady=5)
        
        # Bind events
        self.code_text.bind('<KeyRelease>', self.update_line_numbers)
        self.code_text.bind('<Button-1>', self.update_line_numbers)
        self.code_text.bind('<MouseWheel>', self.on_mousewheel)
        
        # Initialize line numbers
        self.update_line_numbers()
    
    def create_llm_tab(self):
        llm_frame = ttk.Frame(self.notebook)
        self.notebook.add(llm_frame, text="Local LLM (Ollama)")
        
        # Model selection
        model_frame = ttk.Frame(llm_frame)
        model_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(model_frame, text="Model:").pack(side=tk.LEFT)
        self.model_var = tk.StringVar(value="llama3")
        model_entry = ttk.Entry(model_frame, textvariable=self.model_var, width=20)
        model_entry.pack(side=tk.LEFT, padx=5)
        
        # Prompt input
        ttk.Label(llm_frame, text="Your Prompt:").pack(anchor=tk.W, padx=5)
        self.prompt_text = tk.Text(llm_frame, height=6, font=('Arial', 11))
        self.prompt_text.pack(fill=tk.X, padx=5, pady=5)
        
        # Send button
        send_btn = ttk.Button(llm_frame, text="Send to LLM", command=self.send_to_llm)
        send_btn.pack(pady=5)
        
        # Response area
        ttk.Label(llm_frame, text="LLM Response:").pack(anchor=tk.W, padx=5)
        response_frame = ttk.Frame(llm_frame)
        response_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.response_text = tk.Text(response_frame, wrap=tk.WORD, font=('Arial', 11))
        self.response_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        resp_scroll = ttk.Scrollbar(response_frame, orient=tk.VERTICAL, command=self.response_text.yview)
        resp_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.response_text.config(yscrollcommand=resp_scroll.set)
        
        # Copy button
        ttk.Button(llm_frame, text="Copy Response", command=self.copy_response).pack(pady=5)
    
    # Code Editor Methods
    def update_line_numbers(self, event=None):
        self.line_numbers.config(state='normal')
        self.line_numbers.delete('1.0', tk.END)
        line_count = self.code_text.get('1.0', tk.END).count('\n')
        line_numbers_string = "\n".join(str(i) for i in range(1, line_count+1))
        self.line_numbers.insert('1.0', line_numbers_string)
        self.line_numbers.config(state='disabled')
    
    def on_textscroll(self, *args):
        self.code_text.yview(*args)
        self.line_numbers.yview(*args)
    
    def on_mousewheel(self, event):
        self.code_text.yview_scroll(int(-1*(event.delta/120)), "units")
        self.line_numbers.yview_scroll(int(-1*(event.delta/120)), "units")
        return "break"
    
    def save_file(self):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".py",
            filetypes=[("Python files", "*.py"), ("All files", "*.*")]
        )
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(self.code_text.get('1.0', tk.END))
                messagebox.showinfo("Success", f"File saved as {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save file:\n{str(e)}")
    
    def run_code(self):
        if not self.code_text.get('1.0', 'end-1c'):
            messagebox.showwarning("Warning", "Code editor is empty!")
            return
            
        # Save to temporary file
        temp_file = "temp_run_file.py"
        with open(temp_file, 'w') as f:
            f.write(self.code_text.get('1.0', tk.END))
        
        # Run in separate thread to prevent UI blocking
        threading.Thread(target=self.execute_code, args=(temp_file,), daemon=True).start()
    
    def execute_code(self, file_path):
        self.output_text.config(state='normal')
        self.output_text.delete('1.0', tk.END)
        self.output_text.insert('1.0', "Running code...\n")
        self.output_text.config(state='disabled')
        
        try:
            result = subprocess.run(
                ['python', file_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            output = f"STDOUT:\n{result.stdout}\n\nSTDERR:\n{result.stderr}"
        except subprocess.TimeoutExpired:
            output = "Error: Code execution timed out (30s limit)"
        except Exception as e:
            output = f"Execution error: {str(e)}"
        finally:
            # Clean up temp file
            if os.path.exists(file_path):
                os.remove(file_path)
        
        self.output_text.config(state='normal')
        self.output_text.delete('1.0', tk.END)
        self.output_text.insert('1.0', output)
        self.output_text.config(state='disabled')
    
    def copy_code(self):
        self.root.clipboard_clear()
        self.root.clipboard_append(self.code_text.get('1.0', tk.END))
        messagebox.showinfo("Copied", "Code copied to clipboard!")
    
    # LLM Methods
    def send_to_llm(self):
        prompt = self.prompt_text.get('1.0', tk.END).strip()
        if not prompt:
            messagebox.showwarning("Warning", "Please enter a prompt!")
            return
        
        model = self.model_var.get()
        if not model:
            messagebox.showwarning("Warning", "Please specify a model name!")
            return
        
        # Run in separate thread
        threading.Thread(target=self.get_llm_response, args=(model, prompt), daemon=True).start()
    
    def get_llm_response(self, model, prompt):
        self.response_text.delete('1.0', tk.END)
        self.response_text.insert('1.0', "Waiting for LLM response...")
        
        try:
            # Using ollama CLI
            result = subprocess.run(
                ['ollama', 'run', model, prompt],
                capture_output=True,
                text=True,
                timeout=120
            )
            response = result.stdout if result.stdout else result.stderr
        except subprocess.TimeoutExpired:
            response = "Error: LLM request timed out"
        except FileNotFoundError:
            response = "Error: Ollama not found. Please install Ollama first."
        except Exception as e:
            response = f"Error: {str(e)}"
        
        self.response_text.delete('1.0', tk.END)
        self.response_text.insert('1.0', response)
    
    def copy_response(self):
        self.root.clipboard_clear()
        self.root.clipboard_append(self.response_text.get('1.0', tk.END))
        messagebox.showinfo("Copied", "Response copied to clipboard!")

if __name__ == "__main__":
    root = tk.Tk()
    app = CodeEditor(root)
    root.mainloop()
